{"version":3,"file":"abstractEngine.js","sourceRoot":"","sources":["../../../../dev/core/src/Engines/abstractEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { DataArray, FloatArray, ImageSource, IndicesArray, Nullable } from \"../types\";\r\nimport type { PerfCounter } from \"../Misc/perfCounter\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport type { ICanvas, IImage } from \"./ICanvas\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { EngineCapabilities } from \"./engineCapabilities\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport type { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { IAudioEngineOptions } from \"../Audio/Interfaces/IAudioEngineOptions\";\r\nimport type { EngineFeatures } from \"./engineFeatures\";\r\nimport type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport type { IEffectCreationOptions, IShaderPath } from \"../Materials/effect\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport type { IWebRequest } from \"../Misc/interfaces/iWebRequest\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { IInternalTextureLoader } from \"../Materials/Textures/internalTextureLoader\";\r\nimport type { ExternalTexture } from \"../Materials/Textures/externalTexture\";\r\nimport type { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\nimport type { DepthTextureCreationOptions, InternalTextureCreationOptions, RenderTargetCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { IMultiRenderTargetOptions } from \"../Materials/Textures/multiRenderTarget\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport type { IMaterialContext } from \"./IMaterialContext\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IDrawContext } from \"./IDrawContext\";\r\nimport type { VertexBuffer } from \"../Meshes/buffer\";\r\nimport type { IAudioEngine } from \"../Audio/Interfaces/IAudioEngine\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { PerformanceMonitor } from \"core/Misc/performanceMonitor\";\r\nimport type { ILoadingScreen } from \"../Loading/loadingScreen\";\r\nimport { EngineStore } from \"./engineStore\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PerformanceConfigurator } from \"./performanceConfigurator\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { DepthCullingState } from \"../States/depthCullingState\";\r\nimport { StencilStateComposer } from \"../States/stencilStateComposer\";\r\nimport { StencilState } from \"../States/stencilState\";\r\nimport { AlphaState } from \"../States/alphaCullingState\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { IsDocumentAvailable, IsNavigatorAvailable, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { Constants } from \"./constants\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { EngineFunctionContext, _loadFile } from \"./abstractEngine.functions\";\r\n\r\n/**\r\n * Defines the interface used by objects working like Scene\r\n * @internal\r\n */\r\nexport interface ISceneLike {\r\n    /** Add pending data  (to load) */\r\n    addPendingData(data: any): void;\r\n    /** Remove pending data */\r\n    removePendingData(data: any): void;\r\n    /** Offline provider */\r\n    offlineProvider: IOfflineProvider;\r\n}\r\n\r\n/**\r\n * Queue a new function into the requested animation frame pool (ie. this function will be executed by the browser (or the javascript engine) for the next frame)\r\n * @param func - the function to be called\r\n * @param requester - the object that will request the next frame. Falls back to window.\r\n * @returns frame number\r\n */\r\nexport function QueueNewFrame(func: () => void, requester?: any): number {\r\n    // Note that there is kind of a typing issue here, as `setTimeout` might return something else than a number (NodeJs returns a NodeJS.Timeout object).\r\n    // Also if the global `requestAnimationFrame`'s returnType is number, `requester.requestPostAnimationFrame` and `requester.requestAnimationFrame` types\r\n    // are `any`.\r\n\r\n    if (!IsWindowObjectExist()) {\r\n        if (typeof requestAnimationFrame === \"function\") {\r\n            return requestAnimationFrame(func);\r\n        }\r\n    } else {\r\n        const { requestAnimationFrame } = requester || window;\r\n        if (typeof requestAnimationFrame === \"function\") {\r\n            return requestAnimationFrame(func);\r\n        }\r\n    }\r\n\r\n    // fallback to the global `setTimeout`.\r\n    // In most cases (aka in the browser), `window` is the global object, so instead of calling `window.setTimeout` we could call the global `setTimeout`.\r\n    return setTimeout(func, 16) as unknown as number;\r\n}\r\n\r\n/** Interface defining initialization parameters for AbstractEngine class */\r\nexport interface AbstractEngineOptions {\r\n    /**\r\n     * Defines if the engine should no exceed a specified device ratio\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\r\n     */\r\n    limitDeviceRatio?: number;\r\n    /**\r\n     * Defines if webaudio should be initialized as well\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n     */\r\n    audioEngine?: boolean;\r\n    /**\r\n     * Specifies options for the audio engine\r\n     */\r\n    audioEngineOptions?: IAudioEngineOptions;\r\n\r\n    /**\r\n     * Defines if animations should run using a deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    deterministicLockstep?: boolean;\r\n    /** Defines the maximum steps to use with deterministic lock step mode */\r\n    lockstepMaxSteps?: number;\r\n    /** Defines the seconds between each deterministic lock step */\r\n    timeStep?: number;\r\n    /**\r\n     * Defines that engine should ignore context lost events\r\n     * If this event happens when this parameter is true, you will have to reload the page to restore rendering\r\n     */\r\n    doNotHandleContextLost?: boolean;\r\n    /**\r\n     * Defines that engine should ignore modifying touch action attribute and style\r\n     * If not handle, you might need to set it up on your side for expected touch devices behavior.\r\n     */\r\n    doNotHandleTouchAction?: boolean;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n\r\n    /**\r\n     * Defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n\r\n    /**\r\n     * Defines whether MSAA is enabled on the canvas.\r\n     */\r\n    antialias?: boolean;\r\n\r\n    /**\r\n     * Defines whether the stencil buffer should be enabled.\r\n     */\r\n    stencil?: boolean;\r\n\r\n    /**\r\n     * Defines whether the canvas should be created in \"premultiplied\" mode (if false, the canvas is created in the \"opaque\" mode) (true by default)\r\n     */\r\n    premultipliedAlpha?: boolean;\r\n    /**\r\n     * True if the more expensive but exact conversions should be used for transforming colors to and from linear space within shaders.\r\n     * Otherwise, the default is to use a cheaper approximation.\r\n     */\r\n    useExactSrgbConversions?: boolean;\r\n}\r\n\r\n/**\r\n * Information about the current host\r\n */\r\nexport interface HostInformation {\r\n    /**\r\n     * Defines if the current host is a mobile\r\n     */\r\n    isMobile: boolean;\r\n}\r\n\r\nexport type PrepareTextureProcessFunction = (\r\n    width: number,\r\n    height: number,\r\n    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n    extension: string,\r\n    texture: InternalTexture,\r\n    continuationCallback: () => void\r\n) => boolean;\r\n\r\nexport type PrepareTextureFunction = (\r\n    texture: InternalTexture,\r\n    extension: string,\r\n    scene: Nullable<ISceneLike>,\r\n    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n    invertY: boolean,\r\n    noMipmap: boolean,\r\n    isCompressed: boolean,\r\n    processFunction: PrepareTextureProcessFunction,\r\n    samplingMode: number\r\n) => void;\r\n\r\n/**\r\n * The parent class for specialized engines (WebGL, WebGPU)\r\n */\r\nexport abstract class AbstractEngine {\r\n    /** @internal */\r\n    public static _TextureLoaders: IInternalTextureLoader[] = [];\r\n\r\n    // States\r\n    /** @internal */\r\n    protected _colorWrite = true;\r\n    /** @internal */\r\n    protected _colorWriteChanged = true;\r\n    /** @internal */\r\n    public _depthCullingState = new DepthCullingState();\r\n    /** @internal */\r\n    protected _stencilStateComposer = new StencilStateComposer();\r\n    /** @internal */\r\n    public _stencilState = new StencilState();\r\n    /** @internal */\r\n    public _alphaState = new AlphaState();\r\n    /** @internal */\r\n    public _alphaMode = Constants.ALPHA_ADD;\r\n    /** @internal */\r\n    public _alphaEquation = Constants.ALPHA_DISABLE;\r\n\r\n    protected _activeRequests: IFileRequest[] = [];\r\n\r\n    /** @internal */\r\n    public _badOS = false;\r\n    /** @internal */\r\n    public _badDesktopOS = false;\r\n    /** @internal */\r\n    public _videoTextureSupported: boolean;\r\n\r\n    protected _compatibilityMode = true;\r\n    /** @internal */\r\n    public _pointerLockRequested: boolean;\r\n    /** @internal */\r\n    public _loadingScreen: ILoadingScreen;\r\n    /** @internal */\r\n    public _renderingCanvas: Nullable<HTMLCanvasElement>;\r\n    /** @internal */\r\n    public _internalTexturesCache = new Array<InternalTexture>();\r\n    protected _currentEffect: Nullable<Effect>;\r\n    /** @internal */\r\n    protected _cachedVertexBuffers: any;\r\n    /** @internal */\r\n    protected _cachedIndexBuffer: Nullable<DataBuffer>;\r\n    /** @internal */\r\n    protected _cachedEffectForVertexBuffers: Nullable<Effect>;\r\n    /** @internal */\r\n    public _currentRenderTarget: Nullable<RenderTargetWrapper> = null;\r\n    /** @internal */\r\n    public _caps: EngineCapabilities;\r\n    /** @internal */\r\n    protected _cachedViewport: Nullable<IViewportLike>;\r\n    /** @internal */\r\n    public _currentDrawContext: IDrawContext;\r\n\r\n    /** @internal */\r\n    protected _boundTexturesCache: { [key: string]: Nullable<InternalTexture> } = {};\r\n    /** @internal */\r\n    protected _activeChannel = 0;\r\n    /** @internal */\r\n    protected _currentTextureChannel = -1;\r\n    /** @internal */\r\n    protected _viewportCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    /** @internal */\r\n    protected _isWebGPU: boolean = false;\r\n\r\n    // Focus\r\n    /** @internal */\r\n    public _onFocus: () => void;\r\n    /** @internal */\r\n    public _onBlur: () => void;\r\n    /** @internal */\r\n    public _onCanvasPointerOut: (event: PointerEvent) => void;\r\n    /** @internal */\r\n    public _onCanvasBlur: () => void;\r\n    /** @internal */\r\n    public _onCanvasFocus: () => void;\r\n    /** @internal */\r\n    public _onCanvasContextMenu: (evt: Event) => void;\r\n    /** @internal */\r\n    public _onFullscreenChange: () => void;\r\n\r\n    /**\r\n     * Observable event triggered each time the canvas loses focus\r\n     */\r\n    public onCanvasBlurObservable = new Observable<AbstractEngine>();\r\n    /**\r\n     * Observable event triggered each time the canvas gains focus\r\n     */\r\n    public onCanvasFocusObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Event raised when a new scene is created\r\n     */\r\n    public onNewSceneAddedObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * Observable event triggered each time the rendering canvas is resized\r\n     */\r\n    public onResizeObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable event triggered each time the canvas receives pointerout event\r\n     */\r\n    public onCanvasPointerOutObservable = new Observable<PointerEvent>();\r\n\r\n    /**\r\n     * Turn this value on if you want to pause FPS computation when in background\r\n     */\r\n    public disablePerformanceMonitorInBackground = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that vertex array object must be disabled even if they are supported\r\n     */\r\n    public disableVertexArrayObjects = false;\r\n\r\n    /** @internal */\r\n    protected _frameId = 0;\r\n    /**\r\n     * Gets the current frame id\r\n     */\r\n    public get frameId(): number {\r\n        return this._frameId;\r\n    }\r\n    /**\r\n     * Gets a boolean indicating if the engine runs in WebGPU or not.\r\n     */\r\n    public get isWebGPU(): boolean {\r\n        return this._isWebGPU;\r\n    }\r\n\r\n    protected _shaderProcessor: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public abstract areAllEffectsReady(): boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void): void;\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public abstract setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<ThinTexture>, name: string): void;\r\n\r\n    /**\r\n     * Binds an effect to the webGL context\r\n     * @param effect defines the effect to bind\r\n     */\r\n    public abstract bindSamplers(effect: Effect): void;\r\n\r\n    /**\r\n     * Creates an external texture\r\n     * @param video video element\r\n     * @returns the external texture, or null if external textures are not supported by the engine\r\n     */\r\n    public abstract createExternalTexture(video: HTMLVideoElement): Nullable<ExternalTexture>;\r\n\r\n    /**\r\n     * Sets an internal texture to the according uniform.\r\n     * @param name The name of the uniform in the effect\r\n     * @param texture The texture to apply\r\n     */\r\n    public abstract setExternalTexture(name: string, texture: Nullable<ExternalTexture>): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _bindTexture(channel: number, texture: Nullable<InternalTexture>, name: string): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _deletePipelineContext(pipelineContext: IPipelineContext): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        rebuildRebind: any,\r\n        defines: Nullable<string>,\r\n        transformFeedbackVaryings: Nullable<string[]>,\r\n        key: string\r\n    ): void;\r\n\r\n    /** @internal */\r\n    protected _shaderPlatformName: string;\r\n    /**\r\n     * Gets the shader platform name used by the effects.\r\n     */\r\n    public get shaderPlatformName(): string {\r\n        return this._shaderPlatformName;\r\n    }\r\n\r\n    /**\r\n     * Gets information about the current host\r\n     */\r\n    public hostInformation: HostInformation = {\r\n        isMobile: false,\r\n    };\r\n\r\n    /**\r\n     * Gets a boolean indicating if the engine is currently rendering in fullscreen mode\r\n     */\r\n    public isFullscreen = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest\r\n     **/\r\n    public enableOfflineSupport = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (js will always consider the database is up to date)\r\n     **/\r\n    public disableManifestCheck = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable the context menu (right-click) from appearing on the main canvas\r\n     */\r\n    public disableContextMenu: boolean = true;\r\n\r\n    /**\r\n     * Gets or sets the current render pass id\r\n     */\r\n    public currentRenderPassId = Constants.RENDERPASS_MAIN;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the pointer is currently locked\r\n     */\r\n    public isPointerLock = false;\r\n\r\n    /**\r\n     * Gets the list of created postprocesses\r\n     */\r\n    public postProcesses: PostProcess[] = [];\r\n\r\n    /** Gets or sets the tab index to set to the rendering canvas. 1 is the minimum value to set to be able to capture keyboard events */\r\n    public canvasTabIndex = 1;\r\n\r\n    /** @internal */\r\n    protected _onContextLost: (evt: Event) => void;\r\n    /** @internal */\r\n    protected _onContextRestored: (evt: Event) => void;\r\n    /** @internal */\r\n    protected _contextWasLost = false;\r\n\r\n    private _emptyTexture: Nullable<InternalTexture>;\r\n    private _emptyCubeTexture: Nullable<InternalTexture>;\r\n    private _emptyTexture3D: Nullable<InternalTexture>;\r\n    private _emptyTexture2DArray: Nullable<InternalTexture>;\r\n\r\n    protected _clearEmptyResources(): void {\r\n        this._emptyTexture = null;\r\n        this._emptyCubeTexture = null;\r\n        this._emptyTexture3D = null;\r\n        this._emptyTexture2DArray = null;\r\n    }\r\n\r\n    public abstract wipeCaches(bruteForce?: boolean): void;\r\n\r\n    private _useReverseDepthBuffer = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if depth buffer should be reverse, going from far to near.\r\n     * This can provide greater z depth for distant objects.\r\n     */\r\n    public get useReverseDepthBuffer(): boolean {\r\n        return this._useReverseDepthBuffer;\r\n    }\r\n\r\n    public set useReverseDepthBuffer(useReverse) {\r\n        if (useReverse === this._useReverseDepthBuffer) {\r\n            return;\r\n        }\r\n\r\n        this._useReverseDepthBuffer = useReverse;\r\n\r\n        if (useReverse) {\r\n            this._depthCullingState.depthFunc = Constants.GEQUAL;\r\n        } else {\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        if (enable !== this._colorWrite) {\r\n            this._colorWriteChanged = true;\r\n            this._colorWrite = enable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWrite;\r\n    }\r\n\r\n    /**\r\n     * Gets the depth culling state manager\r\n     */\r\n    public get depthCullingState(): DepthCullingState {\r\n        return this._depthCullingState;\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha state manager\r\n     */\r\n    public get alphaState(): AlphaState {\r\n        return this._alphaState;\r\n    }\r\n\r\n    /**\r\n     * Gets the stencil state manager\r\n     */\r\n    public get stencilState(): StencilState {\r\n        return this._stencilState;\r\n    }\r\n\r\n    /**\r\n     * Gets the stencil state composer\r\n     */\r\n    public get stencilStateComposer(): StencilStateComposer {\r\n        return this._stencilStateComposer;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\r\n     */\r\n    public readonly isNDCHalfZRange: boolean = false;\r\n\r\n    /**\r\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\r\n     */\r\n    public readonly hasOriginBottomLeft: boolean = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the exact sRGB conversions or faster approximations are used for converting to and from linear space.\r\n     */\r\n    public readonly useExactSrgbConversions: boolean;\r\n\r\n    /** @internal */\r\n    public _getGlobalDefines(defines?: { [key: string]: string }): string | undefined {\r\n        if (defines) {\r\n            if (this.isNDCHalfZRange) {\r\n                defines[\"IS_NDC_HALF_ZRANGE\"] = \"\";\r\n            } else {\r\n                delete defines[\"IS_NDC_HALF_ZRANGE\"];\r\n            }\r\n            if (this.useReverseDepthBuffer) {\r\n                defines[\"USE_REVERSE_DEPTHBUFFER\"] = \"\";\r\n            } else {\r\n                delete defines[\"USE_REVERSE_DEPTHBUFFER\"];\r\n            }\r\n            if (this.useExactSrgbConversions) {\r\n                defines[\"USE_EXACT_SRGB_CONVERSIONS\"] = \"\";\r\n            } else {\r\n                delete defines[\"USE_EXACT_SRGB_CONVERSIONS\"];\r\n            }\r\n            return;\r\n        } else {\r\n            let s = \"\";\r\n            if (this.isNDCHalfZRange) {\r\n                s += \"#define IS_NDC_HALF_ZRANGE\";\r\n            }\r\n            if (this.useReverseDepthBuffer) {\r\n                if (s) {\r\n                    s += \"\\n\";\r\n                }\r\n                s += \"#define USE_REVERSE_DEPTHBUFFER\";\r\n            }\r\n            if (this.useExactSrgbConversions) {\r\n                if (s) {\r\n                    s += \"\\n\";\r\n                }\r\n                s += \"#define USE_EXACT_SRGB_CONVERSIONS\";\r\n            }\r\n            return s;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderTargetWrapperCache = new Array<RenderTargetWrapper>();\r\n    /** @internal */\r\n    protected _compiledEffects: { [key: string]: Effect } = {};\r\n\r\n    private _rebuildInternalTextures(): void {\r\n        const currentState = this._internalTexturesCache.slice(); // Do a copy because the rebuild will add proxies\r\n\r\n        for (const internalTexture of currentState) {\r\n            internalTexture._rebuild();\r\n        }\r\n    }\r\n\r\n    private _rebuildRenderTargetWrappers(): void {\r\n        const currentState = this._renderTargetWrapperCache.slice(); // Do a copy because the rebuild will add proxies\r\n\r\n        for (const renderTargetWrapper of currentState) {\r\n            renderTargetWrapper._rebuild();\r\n        }\r\n    }\r\n\r\n    private _rebuildEffects(): void {\r\n        for (const key in this._compiledEffects) {\r\n            const effect = <Effect>this._compiledEffects[key];\r\n\r\n            effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\r\n            effect._prepareEffect();\r\n        }\r\n\r\n        Effect.ResetCache();\r\n    }\r\n\r\n    protected _rebuildGraphicsResources(): void {\r\n        // Ensure webgl and engine states are matching\r\n        this.wipeCaches(true);\r\n\r\n        // Rebuild effects\r\n        this._rebuildEffects();\r\n        this._rebuildComputeEffects?.();\r\n\r\n        // Note:\r\n        //  The call to _rebuildBuffers must be made before the call to _rebuildInternalTextures because in the process of _rebuildBuffers the buffers used by the post process managers will be rebuilt\r\n        //  and we may need to use the post process manager of the scene during _rebuildInternalTextures (in WebGL1, non-POT textures are rescaled using a post process + post process manager of the scene)\r\n\r\n        // Rebuild buffers\r\n        this._rebuildBuffers();\r\n        // Rebuild textures\r\n        this._rebuildInternalTextures();\r\n        // Rebuild textures\r\n        this._rebuildTextures();\r\n        // Rebuild textures\r\n        this._rebuildRenderTargetWrappers();\r\n\r\n        // Reset engine states after all the buffer/textures/... have been rebuilt\r\n        this.wipeCaches(true);\r\n    }\r\n\r\n    protected _flagContextRestored(): void {\r\n        Logger.Warn(this.name + \" context successfully restored.\");\r\n        this.onContextRestoredObservable.notifyObservers(this);\r\n        this._contextWasLost = false;\r\n    }\r\n\r\n    protected _restoreEngineAfterContextLost(initEngine: () => void): void {\r\n        // Adding a timeout to avoid race condition at browser level\r\n        setTimeout(async () => {\r\n            this._clearEmptyResources();\r\n\r\n            const depthTest = this._depthCullingState.depthTest; // backup those values because the call to initEngine / wipeCaches will reset them\r\n            const depthFunc = this._depthCullingState.depthFunc;\r\n            const depthMask = this._depthCullingState.depthMask;\r\n            const stencilTest = this._stencilState.stencilTest;\r\n\r\n            // Rebuild context\r\n            await initEngine();\r\n            this._rebuildGraphicsResources();\r\n\r\n            this._depthCullingState.depthTest = depthTest;\r\n            this._depthCullingState.depthFunc = depthFunc;\r\n            this._depthCullingState.depthMask = depthMask;\r\n            this._stencilState.stencilTest = stencilTest;\r\n\r\n            this._flagContextRestored();\r\n        }, 0);\r\n    }\r\n\r\n    /** @internal */\r\n    protected _isDisposed = false;\r\n\r\n    /** Gets a boolean indicating if the engine was disposed */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of created scenes\r\n     */\r\n    public scenes: Scene[] = [];\r\n\r\n    /** @internal */\r\n    public _virtualScenes = new Array<Scene>();\r\n\r\n    /** @internal */\r\n    public _features: EngineFeatures;\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public get snapshotRendering(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set snapshotRendering(activate) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public get snapshotRenderingMode(): number {\r\n        return Constants.SNAPSHOTRENDERING_STANDARD;\r\n    }\r\n\r\n    public set snapshotRenderingMode(mode: number) {}\r\n\r\n    /**\r\n     * Observable event triggered before each texture is initialized\r\n     */\r\n    public onBeforeTextureInitObservable = new Observable<Texture>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foreground\r\n     */\r\n    public renderEvenInBackground = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that cache can be kept between frames\r\n     */\r\n    public preventCacheWipeBetweenFrames = false;\r\n\r\n    /**\r\n     * Returns the string \"AbstractEngine\"\r\n     * @returns \"AbstractEngine\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AbstractEngine\";\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty texture\r\n     */\r\n    public get emptyTexture(): InternalTexture {\r\n        if (!this._emptyTexture) {\r\n            this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        }\r\n\r\n        return this._emptyTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty 3D texture\r\n     */\r\n    public get emptyTexture3D(): InternalTexture {\r\n        if (!this._emptyTexture3D) {\r\n            this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        }\r\n\r\n        return this._emptyTexture3D;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty 2D array texture\r\n     */\r\n    public get emptyTexture2DArray(): InternalTexture {\r\n        if (!this._emptyTexture2DArray) {\r\n            this._emptyTexture2DArray = this.createRawTexture2DArray(\r\n                new Uint8Array(4),\r\n                1,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE\r\n            );\r\n        }\r\n\r\n        return this._emptyTexture2DArray;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty cube texture\r\n     */\r\n    public get emptyCubeTexture(): InternalTexture {\r\n        if (!this._emptyCubeTexture) {\r\n            const faceData = new Uint8Array(4);\r\n            const cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];\r\n            this._emptyCubeTexture = this.createRawCubeTexture(\r\n                cubeData,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE\r\n            );\r\n        }\r\n\r\n        return this._emptyCubeTexture;\r\n    }\r\n\r\n    /** @internal */\r\n    public _frameHandler: number = 0;\r\n\r\n    /** @internal */\r\n    protected _activeRenderLoops = new Array<() => void>();\r\n\r\n    /**\r\n     * Gets the list of current active render loop functions\r\n     * @returns a read only array with the current render loop functions\r\n     */\r\n    public get activeRenderLoops(): ReadonlyArray<() => void> {\r\n        return this._activeRenderLoops;\r\n    }\r\n\r\n    /**\r\n     * stop executing a render loop function and remove it from the execution array\r\n     * @param renderFunction defines the function to be removed. If not provided all functions will be removed.\r\n     */\r\n    public stopRenderLoop(renderFunction?: () => void): void {\r\n        if (!renderFunction) {\r\n            this._activeRenderLoops.length = 0;\r\n            this._cancelFrame();\r\n            return;\r\n        }\r\n\r\n        const index = this._activeRenderLoops.indexOf(renderFunction);\r\n\r\n        if (index >= 0) {\r\n            this._activeRenderLoops.splice(index, 1);\r\n            if (this._activeRenderLoops.length == 0) {\r\n                this._cancelFrame();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _cancelFrame() {\r\n        if (this._frameHandler !== 0) {\r\n            const handlerToCancel = this._frameHandler;\r\n            this._frameHandler = 0;\r\n\r\n            if (!IsWindowObjectExist()) {\r\n                if (typeof cancelAnimationFrame === \"function\") {\r\n                    return cancelAnimationFrame(handlerToCancel);\r\n                }\r\n            } else {\r\n                const { cancelAnimationFrame } = this.getHostWindow() || window;\r\n                if (typeof cancelAnimationFrame === \"function\") {\r\n                    return cancelAnimationFrame(handlerToCancel);\r\n                }\r\n            }\r\n            return clearTimeout(handlerToCancel);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _windowIsBackground = false;\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public beginFrame(): void {\r\n        this.onBeginFrameObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public endFrame(): void {\r\n        this._frameId++;\r\n\r\n        this.onEndFrameObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\r\n     */\r\n    public abstract get performanceMonitor(): PerformanceMonitor;\r\n\r\n    /** @internal */\r\n    public _boundRenderFunction: any = () => this._renderLoop();\r\n\r\n    /** @internal */\r\n    public _renderLoop(): void {\r\n        this._frameHandler = 0;\r\n\r\n        if (!this._contextWasLost) {\r\n            let shouldRender = true;\r\n            if (this._isDisposed || (!this.renderEvenInBackground && this._windowIsBackground)) {\r\n                shouldRender = false;\r\n            }\r\n\r\n            if (shouldRender) {\r\n                // Start new frame\r\n                this.beginFrame();\r\n\r\n                for (let index = 0; index < this._activeRenderLoops.length; index++) {\r\n                    const renderFunction = this._activeRenderLoops[index];\r\n\r\n                    renderFunction();\r\n                }\r\n\r\n                // Present\r\n                this.endFrame();\r\n            }\r\n        }\r\n\r\n        if (this._frameHandler === 0) {\r\n            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used to override the current requestAnimationFrame requester.\r\n     * @internal\r\n     */\r\n    protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number {\r\n        return QueueNewFrame(bindedRenderFunction, requester);\r\n    }\r\n\r\n    /**\r\n     * Register and execute a render loop. The engine can have more than one render function\r\n     * @param renderFunction defines the function to continuously execute\r\n     */\r\n    public runRenderLoop(renderFunction: () => void): void {\r\n        if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._activeRenderLoops.push(renderFunction);\r\n\r\n        // On the first added function, start the render loop.\r\n        if (this._activeRenderLoops.length === 1 && this._frameHandler === 0) {\r\n            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if depth testing is enabled\r\n     * @returns the current state\r\n     */\r\n    public getDepthBuffer(): boolean {\r\n        return this._depthCullingState.depthTest;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth buffering\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthBuffer(enable: boolean): void {\r\n        this._depthCullingState.depthTest = enable;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Factor to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffset(value: number): void {\r\n        this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Factor\r\n     * @returns the current zOffset Factor state\r\n     */\r\n    public getZOffset(): number {\r\n        const zOffset = this._depthCullingState.zOffset;\r\n        return this.useReverseDepthBuffer ? -zOffset : zOffset;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Units to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffsetUnits(value: number): void {\r\n        this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Units\r\n     * @returns the current zOffset Units state\r\n     */\r\n    public getZOffsetUnits(): number {\r\n        const zOffsetUnits = this._depthCullingState.zOffsetUnits;\r\n        return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;\r\n    }\r\n\r\n    /**\r\n     * Gets host window\r\n     * @returns the host window object\r\n     */\r\n    public getHostWindow(): Nullable<Window> {\r\n        if (!IsWindowObjectExist()) {\r\n            return null;\r\n        }\r\n\r\n        if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {\r\n            return this._renderingCanvas.ownerDocument.defaultView;\r\n        }\r\n\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public set compatibilityMode(mode: boolean) {\r\n        // not supported in WebGL\r\n        this._compatibilityMode = true;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the engine is about to compile a shader\r\n     */\r\n    public onBeforeShaderCompilationObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine has just compiled a shader\r\n     */\r\n    public onAfterShaderCompilationObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine begins a new frame\r\n     */\r\n    public onBeginFrameObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine ends the current frame\r\n     */\r\n    public onEndFrameObservable = new Observable<AbstractEngine>();\r\n\r\n    protected _rebuildTextures(): void {\r\n        for (const scene of this.scenes) {\r\n            scene._rebuildTextures();\r\n        }\r\n\r\n        for (const scene of this._virtualScenes) {\r\n            scene._rebuildTextures();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean, maxLevel?: number): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getRGBABufferInternalSizedFormat(type: number, format?: number, useSRGBBuffer?: boolean): number;\r\n\r\n    /** @internal */\r\n    public abstract _getUnpackAlignement(): number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number,\r\n        lod?: number\r\n    ): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _bindTextureDirectly(target: number, texture: Nullable<InternalTexture>, forTextureDataUpdate?: boolean, force?: boolean): boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex?: number,\r\n        lod?: number,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight?: boolean\r\n    ): void;\r\n\r\n    /** @internal */\r\n    public abstract _readTexturePixels(\r\n        texture: InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        faceIndex?: number,\r\n        level?: number,\r\n        buffer?: Nullable<ArrayBufferView>,\r\n        flushRenderer?: boolean,\r\n        noDataConversion?: boolean,\r\n        x?: number,\r\n        y?: number\r\n    ): Promise<ArrayBufferView>;\r\n\r\n    /** @internal */\r\n    public abstract _readTexturePixelsSync(\r\n        texture: InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        faceIndex?: number,\r\n        level?: number,\r\n        buffer?: Nullable<ArrayBufferView>,\r\n        flushRenderer?: boolean,\r\n        noDataConversion?: boolean,\r\n        x?: number,\r\n        y?: number\r\n    ): ArrayBufferView;\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public abstract readPixels(x: number, y: number, width: number, height: number, hasAlpha?: boolean, flushRenderer?: boolean): Promise<ArrayBufferView>;\r\n\r\n    /**\r\n     * Force a WebGPU flush (ie. a flush of all waiting commands)\r\n     */\r\n    public abstract flushFramebuffer(): void;\r\n\r\n    /** @internal */\r\n    public abstract _currentFrameBufferIsDefaultFrameBuffer(): boolean;\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public abstract _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation?: boolean,\r\n        source?: InternalTextureSource\r\n    ): InternalTexture;\r\n\r\n    /** @internal */\r\n    public abstract applyStates(): void;\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public abstract bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex?: number,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel?: number,\r\n        layer?: number\r\n    ): void;\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public abstract updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV?: Nullable<number>, wrapR?: Nullable<number>): void;\r\n\r\n    /**\r\n     * Update a video texture\r\n     * @param texture defines the texture to update\r\n     * @param video defines the video element to use\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     */\r\n    public abstract updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void;\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public abstract restoreDefaultFramebuffer(): void;\r\n\r\n    /**\r\n     * Update a raw texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store in the texture\r\n     * @param format defines the format of the data\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     */\r\n    public abstract updateRawTexture(\r\n        texture: Nullable<InternalTexture>,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression?: Nullable<string>,\r\n        type?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a storage buffer\r\n     * @param data the data for the storage buffer or the size of the buffer\r\n     * @param creationFlags flags to use when creating the buffer (see Constants.BUFFER_CREATIONFLAG_XXX). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns the new buffer\r\n     */\r\n    public abstract createStorageBuffer(data: DataArray | number, creationFlags: number, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Updates a storage buffer\r\n     * @param buffer the storage buffer to update\r\n     * @param data the data used to update the storage buffer\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteLength the byte length of the data\r\n     */\r\n    public abstract updateStorageBuffer(buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;\r\n\r\n    /**\r\n     * Read data from a storage buffer\r\n     * @param storageBuffer The storage buffer to read from\r\n     * @param offset The offset in the storage buffer to start reading from (default: 0)\r\n     * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\r\n     * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\r\n     * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately and not in engine.onEndFrameObservable. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\r\n     * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\r\n     */\r\n    public abstract readFromStorageBuffer(storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView, noDelay?: boolean): Promise<ArrayBufferView>;\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public abstract drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;\r\n\r\n    /**\r\n     * Unbind the current render target texture from the webGL context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public abstract unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n    /**Gets driver info if available */\r\n    public abstract extractDriverInfo(): string;\r\n\r\n    /**\r\n     * Creates a layout object to draw/clear on specific textures in a MRT\r\n     * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n     * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n     */\r\n    public abstract buildTextureLayout(textureStatus: boolean[]): number[];\r\n\r\n    /**\r\n     * Restores the webgl state to only draw on the main color attachment\r\n     * when the frame buffer associated is the canvas frame buffer\r\n     */\r\n    public abstract restoreSingleAttachment(): void;\r\n\r\n    /**\r\n     * Select a subsets of attachments to draw to.\r\n     * @param attachments gl attachments\r\n     */\r\n    public abstract bindAttachments(attachments: number[]): void;\r\n\r\n    /**\r\n     * Bind a list of vertex buffers to the webGL context\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public abstract bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseRenderTargetWrapper(rtWrapper: RenderTargetWrapper): void {\r\n        const index = this._renderTargetWrapperCache.indexOf(rtWrapper);\r\n        if (index !== -1) {\r\n            this._renderTargetWrapperCache.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public abstract enableEffect(effect: Nullable<Effect | DrawWrapper>): void;\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public abstract setState(\r\n        culling: boolean,\r\n        zOffset?: number,\r\n        force?: boolean,\r\n        reverseSide?: boolean,\r\n        cullBackFaces?: boolean,\r\n        stencil?: IStencilState,\r\n        zOffsetUnits?: number\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public abstract createMaterialContext(): IMaterialContext | undefined;\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public abstract createDrawContext(): IDrawContext | undefined;\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @returns the new Effect\r\n     */\r\n    public abstract createEffect(\r\n        baseName: string | (IShaderPath & { vertexToken?: string; fragmentToken?: string }),\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage?: ShaderLanguage\r\n    ): Effect;\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public abstract clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean): void;\r\n\r\n    /**\r\n     * Sets the current alpha mode\r\n     * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     */\r\n    public abstract setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public abstract get needPOTTextures(): boolean;\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param _updatable defines if the index buffer must be updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns a new buffer\r\n     */\r\n    public abstract createIndexBuffer(indices: IndicesArray, _updatable?: boolean, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Creates a new render target texture\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @returns a new render target wrapper ready to render texture\r\n     */\r\n    public abstract createRenderTargetTexture(size: TextureSize, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper;\r\n\r\n    /**\r\n     * Creates a new render target cube wrapper\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @returns a new render target cube wrapper\r\n     */\r\n    public abstract createRenderTargetCubeTexture(size: number, options?: RenderTargetCreationOptions): RenderTargetWrapper;\r\n\r\n    /**\r\n     * Create a multi render target texture\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n     * @param size defines the size of the texture\r\n     * @param options defines the creation options\r\n     * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n     * @returns a new render target wrapper ready to render textures\r\n     */\r\n    public abstract createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n    /** @internal */\r\n    public abstract _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture;\r\n\r\n    /**\r\n     * Creates a depth stencil cube texture.\r\n     * This is only available in WebGL 2.\r\n     * @param size The size of face edge in the cube texture.\r\n     * @param options The options defining the cube texture.\r\n     * @returns The cube texture\r\n     */\r\n    public abstract _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n    /**\r\n     * Update the sample count for a given multiple render target texture\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n     * @param rtWrapper defines the render target wrapper to update\r\n     * @param samples defines the sample count to set\r\n     * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n     * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n     */\r\n    public abstract updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n    /**\r\n     * Updates the sample count of a render target texture\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n     * @param rtWrapper defines the render target wrapper to update\r\n     * @param samples defines the sample count to set\r\n     * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n     */\r\n    public abstract updateRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number;\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public abstract drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;\r\n\r\n    /**\r\n     * Force the engine to release all cached effects.\r\n     * This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public abstract releaseEffects(): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _viewport(x: number, y: number, width: number, height: number): void;\r\n\r\n    /**\r\n     * Gets the current viewport\r\n     */\r\n    public get currentViewport(): Nullable<IViewportLike> {\r\n        return this._cachedViewport;\r\n    }\r\n\r\n    /**\r\n     * Set the WebGL's viewport\r\n     * @param viewport defines the viewport element to be used\r\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n     */\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        const width = requiredWidth || this.getRenderWidth();\r\n        const height = requiredHeight || this.getRenderHeight();\r\n        const x = viewport.x || 0;\r\n        const y = viewport.y || 0;\r\n\r\n        this._cachedViewport = viewport;\r\n\r\n        this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);\r\n    }\r\n\r\n    /**\r\n     * Sets a storage buffer in the shader\r\n     * @param name Defines the name of the storage buffer as defined in the shader\r\n     * @param buffer Defines the value to give to the uniform\r\n     */\r\n    public abstract setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void;\r\n\r\n    /**\r\n     * Sets a texture sampler to the according uniform.\r\n     * @param name The name of the uniform in the effect\r\n     * @param sampler The sampler to apply\r\n     */\r\n    public abstract setTextureSampler(name: string, sampler: Nullable<TextureSampler>): void;\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public abstract updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps?: boolean): void;\r\n\r\n    /**\r\n     * Sets a texture to the context from a postprocess\r\n     * @param channel defines the channel to use\r\n     * @param postProcess defines the source postprocess\r\n     * @param name name of the channel\r\n     */\r\n    public abstract setTextureFromPostProcess(channel: number, postProcess: Nullable<PostProcess>, name: string): void;\r\n\r\n    /**\r\n     * Binds the output of the passed in post process to the texture channel specified\r\n     * @param channel The channel the texture should be bound to\r\n     * @param postProcess The post process which's output should be bound\r\n     * @param name name of the channel\r\n     */\r\n    public abstract setTextureFromPostProcessOutput(channel: number, postProcess: Nullable<PostProcess>, name: string): void;\r\n\r\n    /**\r\n     * Sets an array of texture to the webGL context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param uniform defines the associated uniform location\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public abstract setTextureArray(channel: number, uniform: Nullable<WebGLUniformLocation>, textures: ThinTexture[], name: string): void;\r\n\r\n    /** @internal */\r\n    public _transformTextureUrl: Nullable<(url: string) => string> = null;\r\n\r\n    /**\r\n     * Unbind all instance attributes\r\n     */\r\n    public abstract unbindInstanceAttributes(): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getUseSRGBBuffer(useSRGBBuffer: boolean, noMipmap: boolean): boolean;\r\n\r\n    /**\r\n     * Create an image to use with canvas\r\n     * @returns IImage interface\r\n     */\r\n    public createCanvasImage(): IImage {\r\n        return document.createElement(\"img\");\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public get description(): string {\r\n        let description = this.name + this.version;\r\n\r\n        if (this._caps.parallelShaderCompile) {\r\n            description += \" - Parallel shader compilation\";\r\n        }\r\n\r\n        return description;\r\n    }\r\n\r\n    protected _createTextureBase(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        prepareTexture: PrepareTextureFunction,\r\n        prepareTextureProcess: PrepareTextureProcessFunction,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        url = url || \"\";\r\n        const fromData = url.substr(0, 5) === \"data:\";\r\n        const fromBlob = url.substr(0, 5) === \"blob:\";\r\n        const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\r\n\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\r\n\r\n        if (texture !== fallback) {\r\n            texture.label = url.substring(0, 60); // default label, can be overriden by the caller\r\n        }\r\n\r\n        const originalUrl = url;\r\n        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\r\n            url = this._transformTextureUrl(url);\r\n        }\r\n\r\n        if (originalUrl !== url) {\r\n            texture._originalUrl = originalUrl;\r\n        }\r\n\r\n        // establish the file extension, if possible\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        let extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        let loader: Nullable<IInternalTextureLoader> = null;\r\n\r\n        // Remove query string\r\n        const queryStringIndex = extension.indexOf(\"?\");\r\n\r\n        if (queryStringIndex > -1) {\r\n            extension = extension.split(\"?\")[0];\r\n        }\r\n\r\n        for (const availableLoader of AbstractEngine._TextureLoaders) {\r\n            if (availableLoader.canLoad(extension, mimeType)) {\r\n                loader = availableLoader;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (scene) {\r\n            scene.addPendingData(texture);\r\n        }\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            // Keep a link to the buffer only if we plan to handle context lost\r\n            texture._buffer = buffer;\r\n        }\r\n\r\n        let onLoadObserver: Nullable<Observer<InternalTexture>> = null;\r\n        if (onLoad && !fallback) {\r\n            onLoadObserver = texture.onLoadedObservable.add(onLoad);\r\n        }\r\n\r\n        if (!fallback) {\r\n            this._internalTexturesCache.push(texture);\r\n        }\r\n\r\n        const onInternalError = (message?: string, exception?: any) => {\r\n            if (scene) {\r\n                scene.removePendingData(texture);\r\n            }\r\n\r\n            if (url === originalUrl) {\r\n                if (onLoadObserver) {\r\n                    texture.onLoadedObservable.remove(onLoadObserver);\r\n                }\r\n\r\n                if (EngineStore.UseFallbackTexture && url !== EngineStore.FallbackTexture) {\r\n                    this._createTextureBase(\r\n                        EngineStore.FallbackTexture,\r\n                        noMipmap,\r\n                        texture.invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        null,\r\n                        onError,\r\n                        prepareTexture,\r\n                        prepareTextureProcess,\r\n                        buffer,\r\n                        texture\r\n                    );\r\n                }\r\n\r\n                message = (message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\");\r\n                texture.onErrorObservable.notifyObservers({ message, exception });\r\n                if (onError) {\r\n                    onError(message, exception);\r\n                }\r\n            } else {\r\n                // fall back to the original url if the transformed url fails to load\r\n                Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\r\n                this._createTextureBase(\r\n                    originalUrl,\r\n                    noMipmap,\r\n                    texture.invertY,\r\n                    scene,\r\n                    samplingMode,\r\n                    onLoad,\r\n                    onError,\r\n                    prepareTexture,\r\n                    prepareTextureProcess,\r\n                    buffer,\r\n                    texture,\r\n                    format,\r\n                    forcedExtension,\r\n                    mimeType,\r\n                    loaderOptions,\r\n                    useSRGBBuffer\r\n                );\r\n            }\r\n        };\r\n\r\n        // processing for non-image formats\r\n        if (loader) {\r\n            const callback = (data: ArrayBufferView) => {\r\n                loader!.loadData(\r\n                    data,\r\n                    texture,\r\n                    (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed) => {\r\n                        if (loadFailed) {\r\n                            onInternalError(\"TextureLoader failed to load data\");\r\n                        } else {\r\n                            prepareTexture(\r\n                                texture,\r\n                                extension,\r\n                                scene,\r\n                                { width, height },\r\n                                texture.invertY,\r\n                                !loadMipmap,\r\n                                isCompressed,\r\n                                () => {\r\n                                    done();\r\n                                    return false;\r\n                                },\r\n                                samplingMode\r\n                            );\r\n                        }\r\n                    },\r\n                    loaderOptions\r\n                );\r\n            };\r\n\r\n            if (!buffer) {\r\n                this._loadFile(\r\n                    url,\r\n                    (data) => callback(new Uint8Array(data as ArrayBuffer)),\r\n                    undefined,\r\n                    scene ? scene.offlineProvider : undefined,\r\n                    true,\r\n                    (request?: IWebRequest, exception?: any) => {\r\n                        onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\r\n                    }\r\n                );\r\n            } else {\r\n                if (buffer instanceof ArrayBuffer) {\r\n                    callback(new Uint8Array(buffer));\r\n                } else if (ArrayBuffer.isView(buffer)) {\r\n                    callback(buffer);\r\n                } else {\r\n                    if (onError) {\r\n                        onError(\"Unable to load: only ArrayBuffer or ArrayBufferView is supported\", null);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n                if (fromBlob && !this._doNotHandleContextLost) {\r\n                    // We need to store the image if we need to rebuild the texture\r\n                    // in case of a webgl context lost\r\n                    texture._buffer = img;\r\n                }\r\n\r\n                prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcess, samplingMode);\r\n            };\r\n            // According to the WebGL spec section 6.10, ImageBitmaps must be inverted on creation.\r\n            // So, we pass imageOrientation to _FileToolsLoadImage() as it may create an ImageBitmap.\r\n\r\n            if (!fromData || isBase64) {\r\n                if (buffer && (typeof (<HTMLImageElement>buffer).decoding === \"string\" || (<ImageBitmap>buffer).close)) {\r\n                    onload(<HTMLImageElement>buffer);\r\n                } else {\r\n                    AbstractEngine._FileToolsLoadImage(\r\n                        url || \"\",\r\n                        onload,\r\n                        onInternalError,\r\n                        scene ? scene.offlineProvider : null,\r\n                        mimeType,\r\n                        texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: \"flipY\" } : undefined\r\n                    );\r\n                }\r\n            } else if (typeof buffer === \"string\" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {\r\n                AbstractEngine._FileToolsLoadImage(\r\n                    buffer,\r\n                    onload,\r\n                    onInternalError,\r\n                    scene ? scene.offlineProvider : null,\r\n                    mimeType,\r\n                    texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: \"flipY\" } : undefined\r\n                );\r\n            } else if (buffer) {\r\n                onload(buffer);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public abstract createPipelineContext(shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext;\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public abstract inlineShaderCode(code: string): string;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public abstract get supportsUniformBuffers(): boolean;\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public abstract get version(): number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseEffect(effect: Effect): void;\r\n\r\n    /**\r\n     * Bind a buffer to the current draw context\r\n     * @param buffer defines the buffer to bind\r\n     * @param _location not used in WebGPU\r\n     * @param name Name of the uniform variable to bind\r\n     */\r\n    public abstract bindUniformBufferBase(buffer: DataBuffer, _location: number, name: string): void;\r\n\r\n    /**\r\n     * Bind a specific block at a given index in a specific shader program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param blockName defines the block name\r\n     * @param index defines the index where to bind the block\r\n     */\r\n    public abstract bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;\r\n\r\n    /**\r\n     * Sets a depth stencil texture from a render target to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param uniform The uniform to set\r\n     * @param texture The render target texture containing the depth stencil texture to apply\r\n     * @param name The texture name\r\n     */\r\n    public abstract setDepthStencilTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<RenderTargetTexture>, name?: string): void;\r\n\r\n    /** @internal */\r\n    public _uniformBuffers = new Array<UniformBuffer>();\r\n    /** @internal */\r\n    public _storageBuffers = new Array<StorageBuffer>();\r\n    protected _rebuildBuffers(): void {\r\n        // Uniforms\r\n        for (const uniformBuffer of this._uniformBuffers) {\r\n            uniformBuffer._rebuildAfterContextLost();\r\n        }\r\n    }\r\n\r\n    protected _highPrecisionShadersAllowed = true;\r\n    /** @internal */\r\n    public get _shouldUseHighPrecisionShader(): boolean {\r\n        return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getShaderProcessingContext(shaderLanguage: ShaderLanguage): Nullable<ShaderProcessingContext>;\r\n\r\n    /**\r\n     * Gets host document\r\n     * @returns the host document object\r\n     */\r\n    public getHostDocument(): Nullable<Document> {\r\n        if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {\r\n            return this._renderingCanvas.ownerDocument;\r\n        }\r\n\r\n        return IsDocumentAvailable() ? document : null;\r\n    }\r\n\r\n    // Lost context\r\n    /**\r\n     * Observable signaled when a context lost event is raised\r\n     */\r\n    public onContextLostObservable = new Observable<AbstractEngine>();\r\n    /**\r\n     * Observable signaled when a context restored event is raised\r\n     */\r\n    public onContextRestoredObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Gets the list of loaded textures\r\n     * @returns an array containing all loaded textures\r\n     */\r\n    public getLoadedTexturesCache(): InternalTexture[] {\r\n        return this._internalTexturesCache;\r\n    }\r\n\r\n    /**\r\n     * Clears the list of texture accessible through engine.\r\n     * This can help preventing texture load conflict due to name collision.\r\n     */\r\n    public clearInternalTexturesCache() {\r\n        this._internalTexturesCache.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseTexture(texture: InternalTexture): void;\r\n\r\n    /**\r\n     * Gets the object containing all engine capabilities\r\n     * @returns the EngineCapabilities object\r\n     */\r\n    public getCaps(): EngineCapabilities {\r\n        return this._caps;\r\n    }\r\n\r\n    /**\r\n     * Reset the texture cache to empty state\r\n     */\r\n    public resetTextureCache() {\r\n        for (const key in this._boundTexturesCache) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {\r\n                continue;\r\n            }\r\n            this._boundTexturesCache[key] = null;\r\n        }\r\n\r\n        this._currentTextureChannel = -1;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _name = \"\";\r\n\r\n    /**\r\n     * Gets or sets the name of the engine\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Returns the current npm package of the sdk\r\n     */\r\n    // Not mixed with Version for tooling purpose.\r\n    public static get NpmPackage(): string {\r\n        return \"babylonjs@7.5.0\";\r\n    }\r\n\r\n    /**\r\n     * Returns the current version of the framework\r\n     */\r\n    public static get Version(): string {\r\n        return \"7.5.0\";\r\n    }\r\n\r\n    /**\r\n     * The time (in milliseconds elapsed since the current page has been loaded) when the engine was initialized\r\n     */\r\n    public readonly startTime: number;\r\n\r\n    /** @internal */\r\n    protected _audioContext: Nullable<AudioContext>;\r\n    /** @internal */\r\n    protected _audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>;\r\n    /**\r\n     * Gets the HTML canvas attached with the current webGL context\r\n     * @returns a HTML canvas\r\n     */\r\n    public getRenderingCanvas(): Nullable<HTMLCanvasElement> {\r\n        return this._renderingCanvas;\r\n    }\r\n\r\n    /**\r\n     * Gets the audio context specified in engine initialization options\r\n     * @returns an Audio Context\r\n     */\r\n    public getAudioContext(): Nullable<AudioContext> {\r\n        return this._audioContext;\r\n    }\r\n\r\n    /**\r\n     * Gets the audio destination specified in engine initialization options\r\n     * @returns an audio destination node\r\n     */\r\n    public getAudioDestination(): Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> {\r\n        return this._audioDestination;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the engine has been created with the premultipliedAlpha option on or not.\r\n     */\r\n    public premultipliedAlpha: boolean = true;\r\n\r\n    /**\r\n     * If set to true zooming in and out in the browser will rescale the hardware-scaling correctly.\r\n     */\r\n    public adaptToDeviceRatio: boolean = false;\r\n\r\n    /** @internal */\r\n    protected _lastDevicePixelRatio: number = 1.0;\r\n\r\n    /** @internal */\r\n    public _hardwareScalingLevel: number;\r\n\r\n    /**\r\n     * Defines the hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @param level defines the level to use\r\n     */\r\n    public setHardwareScalingLevel(level: number): void {\r\n        this._hardwareScalingLevel = level;\r\n        this.resize();\r\n    }\r\n\r\n    /**\r\n     * Gets the current hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @returns a number indicating the current hardware scaling level\r\n     */\r\n    public getHardwareScalingLevel(): number {\r\n        return this._hardwareScalingLevel;\r\n    }\r\n\r\n    /** @internal */\r\n    public _doNotHandleContextLost = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#handling-webgl-context-lost\r\n     */\r\n    public get doNotHandleContextLost(): boolean {\r\n        return this._doNotHandleContextLost;\r\n    }\r\n\r\n    public set doNotHandleContextLost(value: boolean) {\r\n        this._doNotHandleContextLost = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _isStencilEnable: boolean;\r\n\r\n    /**\r\n     * Returns true if the stencil buffer has been enabled through the creation option of the context.\r\n     */\r\n    public get isStencilEnable(): boolean {\r\n        return this._isStencilEnable;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _creationOptions: AbstractEngineOptions;\r\n\r\n    /**\r\n     * Gets the options used for engine creation\r\n     * @returns EngineOptions object\r\n     */\r\n    public getCreationOptions() {\r\n        return this._creationOptions;\r\n    }\r\n\r\n    /**\r\n     * Creates a new engine\r\n     * @param antialias defines whether anti-aliasing should be enabled. If undefined, it means that the underlying engine is free to enable it or not\r\n     * @param options defines further options to be sent to the creation context\r\n     * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    constructor(antialias: boolean | undefined, options: AbstractEngineOptions, adaptToDeviceRatio?: boolean) {\r\n        EngineStore.Instances.push(this);\r\n        this.startTime = PrecisionDate.Now;\r\n\r\n        this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        if (IsNavigatorAvailable() && navigator.userAgent) {\r\n            // Detect if we are running on a faulty buggy OS.\r\n            this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);\r\n\r\n            // Detect if we are running on a faulty buggy desktop OS.\r\n            this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n        }\r\n\r\n        // Save this off for use in resize().\r\n        this.adaptToDeviceRatio = adaptToDeviceRatio ?? false;\r\n\r\n        options.antialias = antialias ?? options.antialias;\r\n        options.deterministicLockstep = options.deterministicLockstep ?? false;\r\n        options.lockstepMaxSteps = options.lockstepMaxSteps ?? 4;\r\n        options.timeStep = options.timeStep ?? 1 / 60;\r\n        options.audioEngine = options.audioEngine ?? true;\r\n        options.stencil = options.stencil ?? true;\r\n\r\n        this._audioContext = options.audioEngineOptions?.audioContext ?? null;\r\n        this._audioDestination = options.audioEngineOptions?.audioDestination ?? null;\r\n        this.premultipliedAlpha = options.premultipliedAlpha ?? true;\r\n        this._doNotHandleContextLost = !!options.doNotHandleContextLost;\r\n        this._isStencilEnable = options.stencil ? true : false;\r\n        this.useExactSrgbConversions = options.useExactSrgbConversions ?? false;\r\n\r\n        const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n\r\n        const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\r\n        // Viewport\r\n        adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;\r\n        this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\r\n        this._lastDevicePixelRatio = devicePixelRatio;\r\n\r\n        this._creationOptions = options;\r\n    }\r\n\r\n    /**\r\n     * Resize the view according to the canvas' size\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     */\r\n    public resize(forceSetSize = false): void {\r\n        let width: number;\r\n        let height: number;\r\n\r\n        // Re-query hardware scaling level to handle zoomed-in resizing.\r\n        if (this.adaptToDeviceRatio) {\r\n            const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n            const changeRatio = this._lastDevicePixelRatio / devicePixelRatio;\r\n            this._lastDevicePixelRatio = devicePixelRatio;\r\n            this._hardwareScalingLevel *= changeRatio;\r\n        }\r\n\r\n        if (IsWindowObjectExist() && IsDocumentAvailable()) {\r\n            // make sure it is a Node object, and is a part of the document.\r\n            if (this._renderingCanvas) {\r\n                const boundingRect = this._renderingCanvas.getBoundingClientRect\r\n                    ? this._renderingCanvas.getBoundingClientRect()\r\n                    : {\r\n                          // fallback to last solution in case the function doesn't exist\r\n                          width: this._renderingCanvas.width * this._hardwareScalingLevel,\r\n                          height: this._renderingCanvas.height * this._hardwareScalingLevel,\r\n                      };\r\n                width = this._renderingCanvas.clientWidth || boundingRect.width || this._renderingCanvas.width || 100;\r\n                height = this._renderingCanvas.clientHeight || boundingRect.height || this._renderingCanvas.height || 100;\r\n            } else {\r\n                width = window.innerWidth;\r\n                height = window.innerHeight;\r\n            }\r\n        } else {\r\n            width = this._renderingCanvas ? this._renderingCanvas.width : 100;\r\n            height = this._renderingCanvas ? this._renderingCanvas.height : 100;\r\n        }\r\n\r\n        this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!this._renderingCanvas) {\r\n            return false;\r\n        }\r\n\r\n        width = width | 0;\r\n        height = height | 0;\r\n\r\n        if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {\r\n            return false;\r\n        }\r\n\r\n        this._renderingCanvas.width = width;\r\n        this._renderingCanvas.height = height;\r\n\r\n        if (this.scenes) {\r\n            for (let index = 0; index < this.scenes.length; index++) {\r\n                const scene = this.scenes[index];\r\n\r\n                for (let camIndex = 0; camIndex < scene.cameras.length; camIndex++) {\r\n                    const cam = scene.cameras[camIndex];\r\n\r\n                    cam._currentRenderId = 0;\r\n                }\r\n            }\r\n\r\n            if (this.onResizeObservable.hasObservers()) {\r\n                this.onResizeObservable.notifyObservers(this);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseBuffer(buffer: DataBuffer): boolean;\r\n\r\n    /**\r\n     * Create a dynamic uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public abstract createDynamicUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Create an uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public abstract createUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Update an existing uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param uniformBuffer defines the target uniform buffer\r\n     * @param elements defines the content to update\r\n     * @param offset defines the offset in the uniform buffer where update should start\r\n     * @param count defines the size of the data to update\r\n     */\r\n    public abstract updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void;\r\n\r\n    /**\r\n     * Update a dynamic index buffer\r\n     * @param indexBuffer defines the target index buffer\r\n     * @param indices defines the data to update\r\n     * @param offset defines the offset in the target index buffer where update should start\r\n     */\r\n    public abstract updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset?: number): void;\r\n\r\n    /**\r\n     * Updates a dynamic vertex buffer.\r\n     * @param vertexBuffer the vertex buffer to update\r\n     * @param data the data used to update the vertex buffer\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteLength the byte length of the data\r\n     */\r\n    public abstract updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;\r\n\r\n    /**\r\n     * Creates a dynamic vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL dynamic buffer\r\n     */\r\n    public abstract createDynamicVertexBuffer(data: DataArray | number, _label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data or size for the vertex buffer\r\n     * @param _updatable whether the buffer should be created as updatable\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL static buffer\r\n     */\r\n    public abstract createVertexBuffer(data: DataArray | number, _updatable?: boolean, _label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public abstract updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number): void;\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a WebGLTexture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public abstract createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode?: number,\r\n        onLoad?: Nullable<(texture: InternalTexture) => void>,\r\n        onError?: Nullable<(message: string, exception: any) => void>,\r\n        buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>,\r\n        fallback?: Nullable<InternalTexture>,\r\n        format?: Nullable<number>,\r\n        forcedExtension?: Nullable<string>,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _setupDepthStencilTexture(\r\n        internalTexture: InternalTexture,\r\n        size: number | { width: number; height: number; layers?: number },\r\n        generateStencil: boolean,\r\n        bilinearFiltering: boolean,\r\n        comparisonFunction: number,\r\n        samples?: number\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a raw texture\r\n     * @param data defines the data to store in the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param format defines the format of the data\r\n     * @param generateMipMaps defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the raw texture inside an InternalTexture\r\n     */\r\n    public abstract createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        type?: number,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n     * @param rootUrl defines the url where the file to load is located\r\n     * @param scene defines the current scene\r\n     * @param lodScale defines scale to apply to the mip map selection\r\n     * @param lodOffset defines offset to apply to the mip map selection\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public abstract createPrefilteredCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        lodScale: number,\r\n        lodOffset: number,\r\n        onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>,\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format?: number,\r\n        forcedExtension?: any,\r\n        createPolynomials?: boolean\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Creates a dynamic texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param generateMipMaps defines if the engine should generate the mip levels\r\n     * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @returns the dynamic texture inside an InternalTexture\r\n     */\r\n    public abstract createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n    /**\r\n     * Update the content of a dynamic texture\r\n     * @param texture defines the texture to update\r\n     * @param source defines the source containing the data\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param premulAlpha defines if alpha is stored as premultiplied\r\n     * @param format defines the format of the data\r\n     * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public abstract updateDynamicTexture(\r\n        texture: Nullable<InternalTexture>,\r\n        source: ImageSource | ICanvas,\r\n        invertY?: boolean,\r\n        premulAlpha?: boolean,\r\n        format?: number,\r\n        forceBindTexture?: boolean,\r\n        allowGPUOptimization?: boolean\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a cube texture\r\n     * @param rootUrl defines the url where the files to load is located\r\n     * @param scene defines the current scene\r\n     * @param files defines the list of files to load (1 per face)\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public abstract createCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        files: Nullable<string[]>,\r\n        noMipmap: boolean | undefined,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number | undefined,\r\n        forcedExtension: any,\r\n        createPolynomials: boolean,\r\n        lodScale: number,\r\n        lodOffset: number,\r\n        fallback: Nullable<InternalTexture>,\r\n        loaderOptions: any,\r\n        useSRGBBuffer: boolean\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Creates a cube texture\r\n     * @param rootUrl defines the url where the files to load is located\r\n     * @param scene defines the current scene\r\n     * @param files defines the list of files to load (1 per face)\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public abstract createCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        files: Nullable<string[]>,\r\n        noMipmap: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number | undefined,\r\n        forcedExtension: any\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Creates a cube texture\r\n     * @param rootUrl defines the url where the files to load is located\r\n     * @param scene defines the current scene\r\n     * @param files defines the list of files to load (1 per face)\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public abstract createCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        files: Nullable<string[]>,\r\n        noMipmap: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number | undefined,\r\n        forcedExtension: any,\r\n        createPolynomials: boolean,\r\n        lodScale: number,\r\n        lodOffset: number\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Creates a new raw cube texture\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public abstract createRawCubeTexture(\r\n        data: Nullable<ArrayBufferView[]>,\r\n        size: number,\r\n        format: number,\r\n        type: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Update a raw cube texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     */\r\n    public abstract updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n    /**\r\n     * Update a raw cube texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    public abstract updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n    /**\r\n     * Update a raw cube texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     * @param level defines which level of the texture to update\r\n     */\r\n    public abstract updateRawCubeTexture(\r\n        texture: InternalTexture,\r\n        data: ArrayBufferView[],\r\n        format: number,\r\n        type: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string>,\r\n        level: number\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a new raw cube texture from a specified url\r\n     * @param url defines the url where the data is located\r\n     * @param scene defines the current scene\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n     * @param noMipmap defines if the engine should avoid generating the mip levels\r\n     * @param callback defines a callback used to extract texture data from loaded data\r\n     * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n     * @param onLoad defines a callback called when texture is loaded\r\n     * @param onError defines a callback called if there is an error\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public abstract createRawCubeTextureFromUrl(\r\n        url: string,\r\n        scene: Nullable<Scene>,\r\n        size: number,\r\n        format: number,\r\n        type: number,\r\n        noMipmap: boolean,\r\n        callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n        mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n        onLoad: Nullable<() => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Creates a new raw cube texture from a specified url\r\n     * @param url defines the url where the data is located\r\n     * @param scene defines the current scene\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n     * @param noMipmap defines if the engine should avoid generating the mip levels\r\n     * @param callback defines a callback used to extract texture data from loaded data\r\n     * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n     * @param onLoad defines a callback called when texture is loaded\r\n     * @param onError defines a callback called if there is an error\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public abstract createRawCubeTextureFromUrl(\r\n        url: string,\r\n        scene: Nullable<Scene>,\r\n        size: number,\r\n        format: number,\r\n        type: number,\r\n        noMipmap: boolean,\r\n        callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n        mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n        onLoad: Nullable<() => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>,\r\n        samplingMode: number,\r\n        invertY: boolean\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Creates a new raw 3D texture\r\n     * @param data defines the data used to create the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the depth of the texture\r\n     * @param format defines the format of the texture\r\n     * @param generateMipMaps defines if the engine must generate mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compressed used (can be null)\r\n     * @param textureType defines the compressed used (can be null)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns a new raw 3D texture (stored in an InternalTexture)\r\n     */\r\n    public abstract createRawTexture3D(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        textureType?: number,\r\n        creationFlags?: number\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Update a raw 3D texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     */\r\n    public abstract updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n    /**\r\n     * Update a raw 3D texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the used compression (can be null)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n     */\r\n    public abstract updateRawTexture3D(\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string>,\r\n        textureType: number\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a new raw 2D array texture\r\n     * @param data defines the data used to create the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the format of the texture\r\n     * @param generateMipMaps defines if the engine must generate mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compressed used (can be null)\r\n     * @param textureType defines the compressed used (can be null)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n     */\r\n    public abstract createRawTexture2DArray(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        textureType?: number,\r\n        creationFlags?: number\r\n    ): InternalTexture;\r\n\r\n    /**\r\n     * Update a raw 2D array texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     */\r\n    public abstract updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n    /**\r\n     * Update a raw 2D array texture\r\n     * @param texture defines the texture to update\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the used compression (can be null)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n     */\r\n    public abstract updateRawTexture2DArray(\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string>,\r\n        textureType: number\r\n    ): void;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if back faces must be culled. If false, front faces are culled instead (true by default)\r\n     * If non null, this takes precedence over the value from the material\r\n     */\r\n    public cullBackFaces: Nullable<boolean> = null;\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public abstract getRenderWidth(useScreen?: boolean): number;\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public abstract getRenderHeight(useScreen?: boolean): number;\r\n\r\n    /**\r\n     * Shared initialization across engines types.\r\n     * @param canvas The canvas associated with this instance of the engine.\r\n     */\r\n    protected _sharedInit(canvas: HTMLCanvasElement) {\r\n        this._renderingCanvas = canvas;\r\n    }\r\n\r\n    private _checkForMobile: () => void;\r\n\r\n    protected _setupMobileChecks(): void {\r\n        if (!(navigator && navigator.userAgent)) {\r\n            return;\r\n        }\r\n\r\n        // Function to check if running on mobile device\r\n        this._checkForMobile = () => {\r\n            const currentUA = navigator.userAgent;\r\n            this.hostInformation.isMobile =\r\n                currentUA.indexOf(\"Mobile\") !== -1 ||\r\n                // Needed for iOS 13+ detection on iPad (inspired by solution from https://stackoverflow.com/questions/9038625/detect-if-device-is-ios)\r\n                (currentUA.indexOf(\"Mac\") !== -1 && IsDocumentAvailable() && \"ontouchend\" in document);\r\n        };\r\n\r\n        // Set initial isMobile value\r\n        this._checkForMobile();\r\n\r\n        // Set up event listener to check when window is resized (used to get emulator activation to work properly)\r\n        if (IsWindowObjectExist()) {\r\n            window.addEventListener(\"resize\", this._checkForMobile);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    /** @internal */\r\n    public static _RenderPassIdCounter = 0;\r\n\r\n    /** @internal */\r\n    public _renderPassNames: string[] = [\"main\"];\r\n\r\n    /** @internal */\r\n    public abstract _createHardwareTexture(): HardwareTextureWrapper;\r\n\r\n    /**\r\n     * creates and returns a new video element\r\n     * @param constraints video constraints\r\n     * @returns video element\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createVideoElement(constraints: MediaTrackConstraints): any {\r\n        return document.createElement(\"video\");\r\n    }\r\n\r\n    // FPS\r\n    protected _fps = 60;\r\n    protected _deltaTime = 0;\r\n\r\n    /** @internal */\r\n    public _drawCalls: PerfCounter;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _reportDrawCall(numDrawCalls = 1) {\r\n        this._drawCalls?.addCount(numDrawCalls, false);\r\n    }\r\n    /**\r\n     * Gets the current framerate\r\n     * @returns a number representing the framerate\r\n     */\r\n    public getFps(): number {\r\n        return this._fps;\r\n    }\r\n\r\n    /**\r\n     * Gets the time spent between current and previous frame\r\n     * @returns a number representing the delta time in ms\r\n     */\r\n    public getDeltaTime(): number {\r\n        return this._deltaTime;\r\n    }\r\n\r\n    // Deterministic lockstepMaxSteps\r\n    /** @internal */\r\n    public _deterministicLockstep: boolean = false;\r\n    /** @internal */\r\n    public _lockstepMaxSteps: number = 4;\r\n    /** @internal */\r\n    public _timeStep: number = 1 / 60;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns true if engine is in deterministic lock step mode\r\n     */\r\n    public isDeterministicLockStep(): boolean {\r\n        return this._deterministicLockstep;\r\n    }\r\n\r\n    /**\r\n     * Gets the max steps when engine is running in deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns the max steps\r\n     */\r\n    public getLockstepMaxSteps(): number {\r\n        return this._lockstepMaxSteps;\r\n    }\r\n\r\n    /**\r\n     * Returns the time in ms between steps when using deterministic lock step.\r\n     * @returns time step in (ms)\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep * 1000;\r\n    }\r\n\r\n    /**\r\n     * Force the mipmap generation for the given render target texture\r\n     * @param texture defines the render target texture to use\r\n     * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.\r\n     */\r\n    public abstract generateMipMapsForCubemap(texture: InternalTexture, unbind: boolean): void;\r\n\r\n    /**\r\n     * Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     */\r\n    public _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        throw new Error(\"createImageBitmapFromSource is not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for createImageBitmap\r\n     * @param image source for image\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return createImageBitmap(image, options);\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     */\r\n    public resizeImageBitmap(image: HTMLImageElement | ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        throw new Error(\"resizeImageBitmap is not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Get the current error code of the webGL context\r\n     * @returns the error code\r\n     */\r\n    public abstract getError(): number;\r\n\r\n    /**\r\n     * Get Font size information\r\n     * @param font font name\r\n     */\r\n    public getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        throw new Error(\"getFontOffset is not implemented\");\r\n    }\r\n\r\n    protected static _CreateCanvas(width: number, height: number): ICanvas {\r\n        if (typeof document === \"undefined\") {\r\n            return <ICanvas>(<any>new OffscreenCanvas(width, height));\r\n        }\r\n        const canvas = <ICanvas>(<any>document.createElement(\"canvas\"));\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Create a canvas. This method is overridden by other engines\r\n     * @param width width\r\n     * @param height height\r\n     * @returns ICanvas interface\r\n     */\r\n    public createCanvas(width: number, height: number): ICanvas {\r\n        return AbstractEngine._CreateCanvas(width, height);\r\n    }\r\n\r\n    /**\r\n     * Loads an image as an HTMLImageElement.\r\n     * @param input url string, ArrayBuffer, or Blob to load\r\n     * @param onLoad callback called when the image successfully loads\r\n     * @param onError callback called when the image fails to load\r\n     * @param offlineProvider offline provider for caching\r\n     * @param mimeType optional mime type\r\n     * @param imageBitmapOptions optional the options to use when creating an ImageBitmap\r\n     * @returns the HTMLImageElement of the loaded image\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadImage(\r\n        input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string,\r\n        imageBitmapOptions?: ImageBitmapOptions\r\n    ): Nullable<HTMLImageElement> {\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (data: any) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: IWebRequest, exception?: any) => void\r\n    ): IFileRequest {\r\n        const request = _loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add(() => {\r\n            const index = this._activeRequests.indexOf(request);\r\n            if (index !== -1) {\r\n                this._activeRequests.splice(index, 1);\r\n            }\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        if (EngineFunctionContext.loadFile) {\r\n            return EngineFunctionContext.loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        }\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the engine is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.hideLoadingUI();\r\n\r\n        this.releaseEffects();\r\n\r\n        this._isDisposed = true;\r\n        this.stopRenderLoop();\r\n\r\n        // Empty texture\r\n        if (this._emptyTexture) {\r\n            this._releaseTexture(this._emptyTexture);\r\n            this._emptyTexture = null;\r\n        }\r\n        if (this._emptyCubeTexture) {\r\n            this._releaseTexture(this._emptyCubeTexture);\r\n            this._emptyCubeTexture = null;\r\n        }\r\n\r\n        this._renderingCanvas = null;\r\n\r\n        // Clear observables\r\n        if (this.onBeforeTextureInitObservable) {\r\n            this.onBeforeTextureInitObservable.clear();\r\n        }\r\n\r\n        // Release postProcesses\r\n        while (this.postProcesses.length) {\r\n            this.postProcesses[0].dispose();\r\n        }\r\n\r\n        // Release scenes\r\n        while (this.scenes.length) {\r\n            this.scenes[0].dispose();\r\n        }\r\n\r\n        while (this._virtualScenes.length) {\r\n            this._virtualScenes[0].dispose();\r\n        }\r\n\r\n        // Release effects\r\n        this.releaseComputeEffects?.();\r\n\r\n        Effect.ResetCache();\r\n\r\n        // Abort active requests\r\n        for (const request of this._activeRequests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._boundRenderFunction = null;\r\n\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.onResizeObservable.clear();\r\n        this.onCanvasBlurObservable.clear();\r\n        this.onCanvasFocusObservable.clear();\r\n        this.onCanvasPointerOutObservable.clear();\r\n        this.onNewSceneAddedObservable.clear();\r\n\r\n        if (IsWindowObjectExist()) {\r\n            window.removeEventListener(\"resize\", this._checkForMobile);\r\n        }\r\n\r\n        // Remove from Instances\r\n        const index = EngineStore.Instances.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            EngineStore.Instances.splice(index, 1);\r\n        }\r\n\r\n        // no more engines left in the engine store? Notify!\r\n        if (!EngineStore.Instances.length) {\r\n            EngineStore.OnEnginesDisposedObservable.notifyObservers(this);\r\n        }\r\n\r\n        // Observables\r\n        this.onBeginFrameObservable.clear();\r\n        this.onEndFrameObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Method called to create the default rescale post process on each engine.\r\n     */\r\n    public static _RescalePostProcessFactory: Nullable<(engine: AbstractEngine) => PostProcess> = null;\r\n\r\n    /**\r\n     * Method called to create the default loading screen.\r\n     * This can be overridden in your own app.\r\n     * @param canvas The rendering canvas element\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static DefaultLoadingScreenFactory(canvas: HTMLCanvasElement): ILoadingScreen {\r\n        throw _WarnImport(\"LoadingScreen\");\r\n    }\r\n\r\n    /**\r\n     * Gets the audio engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static audioEngine: Nullable<IAudioEngine>;\r\n\r\n    /**\r\n     * Default AudioEngine factory responsible of creating the Audio Engine.\r\n     * By default, this will create a BabylonJS Audio Engine if the workload has been embedded.\r\n     */\r\n    public static AudioEngineFactory: (\r\n        hostElement: Nullable<HTMLElement>,\r\n        audioContext: Nullable<AudioContext>,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n    ) => IAudioEngine;\r\n\r\n    /**\r\n     * Default offline support factory responsible of creating a tool used to store data locally.\r\n     * By default, this will create a Database object if the workload has been embedded.\r\n     */\r\n    public static OfflineProviderFactory: (urlToScene: string, callbackManifestChecked: (checked: boolean) => any, disableManifestCheck: boolean) => IOfflineProvider;\r\n}\r\n"]}